/*!
  * hjson v0.0.1 (https://github.com/alvarolm/hjson-js)
  * Copyright 2024 Alvaro Leiva Miranda (https://github.com/alvarolm)
  * Licensed under MIT (https://github.com/alvarolm/hjson-js/blob/main/LICENSE.md)
  */

var hjson = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // hjson.js
  var hjson_exports = {};
  __export(hjson_exports, {
    parse: () => parse2,
    stringify: () => stringify2
  });

  // parser.js
  var Parser = class {
    constructor(text) {
      this.text = text;
      this.pos = 0;
      this.line = 1;
      this.ch = " ";
    }
    parse() {
      this.nextChar();
      this.skipWhitespace();
      const result = this.parseValue();
      this.skipWhitespace();
      if (this.pos < this.text.length) {
        throw new Error(`Unexpected character at position ${this.pos}`);
      }
      return result;
    }
    nextChar() {
      if (this.pos < this.text.length) {
        this.ch = this.text.charAt(this.pos++);
        if (this.ch === "\n") {
          this.line++;
        }
        return true;
      }
      return false;
    }
    skipWhitespace() {
      while (this.ch === " " || this.ch === "	" || this.ch === "\n" || this.ch === "\r") {
        this.nextChar();
      }
      while (this.ch === "#" || this.ch === "/" && (this.text[this.pos] === "/" || this.text[this.pos] === "*")) {
        if (this.ch === "#" || this.text[this.pos] === "/") {
          while (this.ch !== "\n" && this.pos < this.text.length) {
            this.nextChar();
          }
        } else if (this.text[this.pos] === "*") {
          this.nextChar();
          this.nextChar();
          while (this.pos < this.text.length) {
            if (this.ch === "*" && this.text[this.pos] === "/") {
              this.nextChar();
              this.nextChar();
              break;
            }
            this.nextChar();
          }
        }
        this.skipWhitespace();
      }
    }
    parseValue() {
      this.skipWhitespace();
      switch (this.ch) {
        case "{":
          return this.parseObject();
        case "[":
          return this.parseArray();
        case '"':
          return this.parseJSONString();
        case "'": {
          if (this.text[this.pos] === "'" && this.text[this.pos + 1] === "'") {
            return this.parseMultilineString();
          }
          return this.parseQuotedString();
        }
        default: {
          if (this.ch === "-" || this.ch >= "0" && this.ch <= "9") {
            return this.parseNumber();
          }
          const specialValues = this.parseSpecialValue();
          if (specialValues !== void 0) {
            return specialValues;
          }
          return this.parseQuotelessString();
        }
      }
    }
    parseObject() {
      const obj = {};
      this.nextChar();
      this.skipWhitespace();
      while (this.ch !== "}" && this.pos < this.text.length) {
        let key;
        if (this.ch === '"') {
          key = this.parseJSONString();
        } else if (this.ch === "'") {
          if (this.text[this.pos] === "'" && this.text[this.pos + 1] === "'") {
            key = this.parseMultilineString();
          } else {
            key = this.parseQuotedString();
          }
        } else {
          key = this.parseQuotelessString();
        }
        this.skipWhitespace();
        if (this.ch === ":") {
          this.nextChar();
          this.skipWhitespace();
        }
        const value = this.parseValue();
        obj[key] = value;
        this.skipWhitespace();
        if (this.ch === ",") {
          this.nextChar();
          this.skipWhitespace();
        }
      }
      if (this.ch === "}") {
        this.nextChar();
      }
      return obj;
    }
    parseArray() {
      const arr = [];
      this.nextChar();
      this.skipWhitespace();
      while (this.ch !== "]" && this.pos < this.text.length) {
        arr.push(this.parseValue());
        this.skipWhitespace();
        if (this.ch === ",") {
          this.nextChar();
          this.skipWhitespace();
        }
      }
      if (this.ch === "]") {
        this.nextChar();
      }
      return arr;
    }
    parseJSONString() {
      let str = "";
      this.nextChar();
      while (this.ch !== '"' && this.pos < this.text.length) {
        if (this.ch === "\\") {
          this.nextChar();
          switch (this.ch) {
            case "b":
              str += "\b";
              break;
            case "f":
              str += "\f";
              break;
            case "n":
              str += "\n";
              break;
            case "r":
              str += "\r";
              break;
            case "t":
              str += "	";
              break;
            case "u": {
              let hexValue = "";
              for (let i = 0; i < 4; i++) {
                this.nextChar();
                hexValue += this.ch;
              }
              str += String.fromCharCode(Number.parseInt(hexValue, 16));
              break;
            }
            default:
              str += this.ch;
          }
        } else {
          str += this.ch;
        }
        this.nextChar();
      }
      this.nextChar();
      return str;
    }
    parseQuotedString() {
      let str = "";
      this.nextChar();
      while (this.ch !== "'" && this.pos < this.text.length) {
        if (this.ch === "\\") {
          this.nextChar();
          switch (this.ch) {
            case "b":
              str += "\b";
              break;
            case "f":
              str += "\f";
              break;
            case "n":
              str += "\n";
              break;
            case "r":
              str += "\r";
              break;
            case "t":
              str += "	";
              break;
            default:
              str += this.ch;
          }
        } else {
          str += this.ch;
        }
        this.nextChar();
      }
      this.nextChar();
      return str;
    }
    parseMultilineString() {
      let str = "";
      let firstLine = true;
      let baseIndent = "";
      this.nextChar();
      this.nextChar();
      this.nextChar();
      if (this.ch === "\n") {
        this.nextChar();
        while (this.ch === " " || this.ch === "	") {
          baseIndent += this.ch;
          this.nextChar();
        }
      }
      while (this.pos < this.text.length) {
        if (this.ch === "'" && this.text[this.pos] === "'" && this.text[this.pos + 1] === "'") {
          this.nextChar();
          this.nextChar();
          this.nextChar();
          break;
        }
        if (this.ch === "\n") {
          if (!firstLine) {
            str += "\n";
          }
          this.nextChar();
          let currentIndent = "";
          while ((this.ch === " " || this.ch === "	") && currentIndent.length < baseIndent.length) {
            currentIndent += this.ch;
            this.nextChar();
          }
          firstLine = false;
        } else {
          str += this.ch;
          this.nextChar();
        }
      }
      return str.trim();
    }
    parseQuotelessString() {
      let str = "";
      while (this.pos <= this.text.length && this.ch !== "," && this.ch !== "}" && this.ch !== "]" && this.ch !== ":" && this.ch !== "\n") {
        str += this.ch;
        this.nextChar();
      }
      return str.trim();
    }
    parseNumber() {
      let numStr = "";
      if (this.ch === "-") {
        numStr += this.ch;
        this.nextChar();
      }
      while (this.ch >= "0" && this.ch <= "9") {
        numStr += this.ch;
        this.nextChar();
      }
      if (this.ch === ".") {
        numStr += this.ch;
        this.nextChar();
        while (this.ch >= "0" && this.ch <= "9") {
          numStr += this.ch;
          this.nextChar();
        }
      }
      if (this.ch === "e" || this.ch === "E") {
        numStr += this.ch;
        this.nextChar();
        if (this.ch === "+" || this.ch === "-") {
          numStr += this.ch;
          this.nextChar();
        }
        while (this.ch >= "0" && this.ch <= "9") {
          numStr += this.ch;
          this.nextChar();
        }
      }
      return Number.parseFloat(numStr);
    }
    parseSpecialValue() {
      const remaining = this.text.slice(this.pos - 1);
      if (remaining.startsWith("true")) {
        this.pos += 3;
        this.nextChar();
        return true;
      }
      if (remaining.startsWith("false")) {
        this.pos += 4;
        this.nextChar();
        return false;
      }
      if (remaining.startsWith("null")) {
        this.pos += 3;
        this.nextChar();
        return null;
      }
      return void 0;
    }
  };
  function parse(text) {
    const parser = new Parser(text);
    return parser.parse();
  }

  // stringify.js
  var Stringifier = class {
    constructor(options = {}) {
      this.indent = options.indent || 2;
      this.currentIndent = 0;
      this.seen = /* @__PURE__ */ new WeakMap();
    }
    getIndentation() {
      return " ".repeat(this.currentIndent);
    }
    stringify(value, pretty = true) {
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "undefined";
      }
      switch (typeof value) {
        case "string":
          return this.stringifyString(value);
        case "number":
          return this.stringifyNumber(value);
        case "boolean":
          return value.toString();
        case "object": {
          if (value instanceof Object) {
            if (this.seen.has(value)) {
              return '"[Circular Reference]"';
            }
            this.seen.set(value, true);
          }
          try {
            if (Array.isArray(value)) {
              return this.stringifyArray(value, pretty);
            }
            return this.stringifyObject(value, pretty);
          } finally {
            if (value instanceof Object) {
              this.seen.delete(value);
            }
          }
        }
        default:
          return String(value);
      }
    }
    stringifyString(str) {
      if (str.includes("\n")) {
        return this.stringifyMultilineString(str);
      }
      if (/["\\\b\f\n\r\t]/.test(str) || /'/.test(str)) {
        return JSON.stringify(str);
      }
      if (/[\s,\{\}\[\]:"]/.test(str)) {
        return `'${str}'`;
      }
      return str;
    }
    stringifyMultilineString(str) {
      const lines = str.split("\n");
      const baseIndent = this.getIndentation();
      const formattedLines = lines.map((line, index) => {
        if (index === 0) {
          return line;
        }
        return baseIndent + line;
      });
      return `'''${formattedLines.length > 1 ? "\n" : ""}${formattedLines.join("\n")}${formattedLines.length > 1 ? "\n" + baseIndent : ""}'''`;
    }
    stringifyNumber(num) {
      if (Number.isNaN(num)) {
        return "null";
      }
      if (!Number.isFinite(num)) {
        return "null";
      }
      return num.toString();
    }
    stringifyArray(arr, pretty) {
      if (arr.length === 0) {
        return "[]";
      }
      this.currentIndent += this.indent;
      const items = arr.map((item) => {
        const value = this.stringify(item, pretty);
        return pretty ? this.getIndentation() + value : value;
      });
      this.currentIndent -= this.indent;
      const separator = pretty ? ",\n" : ", ";
      const openBracket = pretty ? "[\n" : "[";
      const closeBracket = pretty ? `
${this.getIndentation()}]` : "]";
      return `${openBracket}${items.join(separator)}${closeBracket}`;
    }
    stringifyObject(obj, pretty) {
      if (Object.keys(obj).length === 0) {
        return "{}";
      }
      this.currentIndent += this.indent;
      const items = Object.entries(obj).map(([key, value]) => {
        const stringifiedKey = this.stringifyString(key);
        const stringifiedValue = this.stringify(value, pretty);
        return pretty ? `${this.getIndentation()}${stringifiedKey}: ${stringifiedValue}` : `${stringifiedKey}: ${stringifiedValue}`;
      });
      this.currentIndent -= this.indent;
      const separator = pretty ? ",\n" : ", ";
      const openBrace = pretty ? "{\n" : "{";
      const closeBrace = pretty ? `
${this.getIndentation()}}` : "}";
      return `${openBrace}${items.join(separator)}${closeBrace}`;
    }
  };
  var stringify = function(value, options = {}) {
    const stringifier = new Stringifier(options);
    return stringifier.stringify(value, options.pretty !== false);
  };

  // hjson.js
  var stringify2 = stringify;
  var parse2 = parse;
  return __toCommonJS(hjson_exports);
})();
